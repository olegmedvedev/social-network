package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"errors"
	"strconv"

	"social-network/graph/model"
	"social-network/internal/auth"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, name string, email string, password string) (*model.User, error) {
	_, err := r.Resolver.Repo.GetUserByEmail(ctx, email)
	if err == nil {
		return nil, errors.New("user already exists")
	}
	user, err := r.Resolver.Repo.CreateUser(ctx, name, email, password)
	if err != nil {
		return nil, err
	}
	return &model.User{ID: strconv.Itoa(user.ID), Name: user.Name, Email: user.Email}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*string, error) {
	user, err := r.Resolver.Repo.GetUserByEmail(ctx, email)
	if err != nil {
		return nil, errors.New("invalid credentials")
	}
	err = r.Resolver.Repo.CheckPassword(user.PasswordHash, password)
	if err != nil {
		return nil, errors.New("invalid credentials")
	}
	token, err := auth.GenerateJWT(user.ID)
	if err != nil {
		return nil, errors.New("failed to generate token")
	}
	return &token, nil
}

// Helper to get current user ID from JWT in context
func getCurrentUserID(ctx context.Context) (int, error) {
	token := ""
	if authHeader := ctx.Value("Authorization"); authHeader != nil {
		token, _ = authHeader.(string)
	}
	if token == "" {
		return 0, errors.New("no token provided")
	}
	userID, err := auth.ParseJWT(token)
	if err != nil {
		return 0, errors.New("invalid token")
	}
	return userID, nil
}

func (r *mutationResolver) SendFriendRequest(ctx context.Context, toUserId string) (*model.FriendRequest, error) {
	fromUserID, err := getCurrentUserID(ctx)
	if err != nil {
		return nil, err
	}
	toID, err := strconv.Atoi(toUserId)
	if err != nil {
		return nil, errors.New("invalid toUserId")
	}
	fr, err := r.Resolver.Repo.SendFriendRequest(ctx, fromUserID, toID)
	if err != nil {
		return nil, err
	}
	fromUser, _ := r.Resolver.Repo.GetUserByID(ctx, fr.FromUserID)
	toUser, _ := r.Resolver.Repo.GetUserByID(ctx, fr.ToUserID)
	return &model.FriendRequest{
		ID:        strconv.Itoa(fr.ID),
		From:      &model.User{ID: strconv.Itoa(fromUser.ID), Name: fromUser.Name, Email: fromUser.Email},
		To:        &model.User{ID: strconv.Itoa(toUser.ID), Name: toUser.Name, Email: toUser.Email},
		CreatedAt: fr.CreatedAt,
	}, nil
}

func (r *mutationResolver) AcceptFriendRequest(ctx context.Context, requestId string) (*model.Friend, error) {
	userID, err := getCurrentUserID(ctx)
	if err != nil {
		return nil, err
	}
	reqID, err := strconv.Atoi(requestId)
	if err != nil {
		return nil, errors.New("invalid requestId")
	}
	// Check that this user is the recipient
	frs, err := r.Resolver.Repo.GetIncomingFriendRequests(ctx, userID)
	if err != nil {
		return nil, err
	}
	found := false
	var fromUserID int
	for _, fr := range frs {
		if fr.ID == reqID {
			found = true
			fromUserID = fr.FromUserID
			break
		}
	}
	if !found {
		return nil, errors.New("friend request not found or not for this user")
	}
	if err := r.Resolver.Repo.AcceptFriendRequest(ctx, reqID); err != nil {
		return nil, err
	}
	fromUser, _ := r.Resolver.Repo.GetUserByID(ctx, fromUserID)
	return &model.Friend{ID: strconv.Itoa(fromUser.ID), Name: fromUser.Name, Email: fromUser.Email}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, err := getCurrentUserID(ctx)
	if err != nil {
		return nil, err
	}
	user, err := r.Resolver.Repo.GetUserByID(ctx, userID)
	if err != nil {
		return nil, errors.New("user not found")
	}
	return &model.User{ID: strconv.Itoa(user.ID), Name: user.Name, Email: user.Email}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	userID, err := strconv.Atoi(id)
	if err != nil {
		return nil, errors.New("invalid id")
	}
	user, err := r.Resolver.Repo.GetUserByID(ctx, userID)
	if err != nil {
		return nil, errors.New("user not found")
	}
	return &model.User{ID: strconv.Itoa(user.ID), Name: user.Name, Email: user.Email}, nil
}

func (r *queryResolver) Friends(ctx context.Context, userId string) ([]*model.Friend, error) {
	id, err := strconv.Atoi(userId)
	if err != nil {
		return nil, errors.New("invalid userId")
	}
	friendIDs, err := r.Resolver.Repo.GetFriends(ctx, id)
	if err != nil {
		return nil, err
	}
	var friends []*model.Friend
	for _, fid := range friendIDs {
		u, err := r.Resolver.Repo.GetUserByID(ctx, fid)
		if err == nil {
			friends = append(friends, &model.Friend{ID: strconv.Itoa(u.ID), Name: u.Name, Email: u.Email})
		}
	}
	return friends, nil
}

func (r *queryResolver) IncomingFriendRequests(ctx context.Context) ([]*model.FriendRequest, error) {
	userID, err := getCurrentUserID(ctx)
	if err != nil {
		return nil, err
	}
	frs, err := r.Resolver.Repo.GetIncomingFriendRequests(ctx, userID)
	if err != nil {
		return nil, err
	}
	var result []*model.FriendRequest
	for _, fr := range frs {
		fromUser, _ := r.Resolver.Repo.GetUserByID(ctx, fr.FromUserID)
		toUser, _ := r.Resolver.Repo.GetUserByID(ctx, fr.ToUserID)
		result = append(result, &model.FriendRequest{
			ID:        strconv.Itoa(fr.ID),
			From:      &model.User{ID: strconv.Itoa(fromUser.ID), Name: fromUser.Name, Email: fromUser.Email},
			To:        &model.User{ID: strconv.Itoa(toUser.ID), Name: toUser.Name, Email: toUser.Email},
			CreatedAt: fr.CreatedAt,
		})
	}
	return result, nil
}

func (r *queryResolver) OutgoingFriendRequests(ctx context.Context) ([]*model.FriendRequest, error) {
	userID, err := getCurrentUserID(ctx)
	if err != nil {
		return nil, err
	}
	frs, err := r.Resolver.Repo.GetOutgoingFriendRequests(ctx, userID)
	if err != nil {
		return nil, err
	}
	var result []*model.FriendRequest
	for _, fr := range frs {
		fromUser, _ := r.Resolver.Repo.GetUserByID(ctx, fr.FromUserID)
		toUser, _ := r.Resolver.Repo.GetUserByID(ctx, fr.ToUserID)
		result = append(result, &model.FriendRequest{
			ID:        strconv.Itoa(fr.ID),
			From:      &model.User{ID: strconv.Itoa(fromUser.ID), Name: fromUser.Name, Email: fromUser.Email},
			To:        &model.User{ID: strconv.Itoa(toUser.ID), Name: toUser.Name, Email: toUser.Email},
			CreatedAt: fr.CreatedAt,
		})
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
