package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strconv"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"social-network/graph/model"
	"social-network/internal/db"
	"social-network/internal/config"
)

var jwtSecret = []byte(os.Getenv("JWT_SECRET"))

func generateJWT(userID int) (string, error) {
	claims := jwt.MapClaims{
		"user_id": userID,
		"exp":     time.Now().Add(24 * time.Hour).Unix(),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(jwtSecret)
}

func parseJWT(tokenStr string) (int, error) {
	token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {
		return jwtSecret, nil
	})
	if err != nil || !token.Valid {
		return 0, errors.New("invalid token")
	}
	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		return 0, errors.New("invalid claims")
	}
	idFloat, ok := claims["user_id"].(float64)
	if !ok {
		return 0, errors.New("invalid user_id")
	}
	return int(idFloat), nil
}

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	return nil, errors.New("not implemented")
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, name string, email string, password string) (*model.User, error) {
	_, err := db.GetUserByEmail(ctx, email)
	if err == nil {
		return nil, errors.New("user already exists")
	}
	user, err := db.CreateUser(ctx, name, email, password)
	if err != nil {
		return nil, err
	}
	return &model.User{ID: strconv.Itoa(user.ID), Name: user.Name, Email: user.Email}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*string, error) {
	user, err := db.GetUserByEmail(ctx, email)
	if err != nil {
		return nil, errors.New("invalid credentials")
	}
	err = db.CheckPassword(user.PasswordHash, password)
	if err != nil {
		return nil, errors.New("invalid credentials")
	}
	token, err := generateJWT(user.ID)
	if err != nil {
		return nil, errors.New("failed to generate token")
	}
	return &token, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	return nil, errors.New("not implemented")
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	token := ""
	if auth := ctx.Value("Authorization"); auth != nil {
		token, _ = auth.(string)
	}
	if token == "" {
		return nil, errors.New("no token provided")
	}
	userID, err := parseJWT(token)
	if err != nil {
		return nil, errors.New("invalid token")
	}
	user, err := db.GetUserByID(ctx, userID)
	if err != nil {
		return nil, errors.New("user not found")
	}
	return &model.User{ID: strconv.Itoa(user.ID), Name: user.Name, Email: user.Email}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	userID, err := strconv.Atoi(id)
	if err != nil {
		return nil, errors.New("invalid id")
	}
	user, err := db.GetUserByID(ctx, userID)
	if err != nil {
		return nil, errors.New("user not found")
	}
	return &model.User{ID: strconv.Itoa(user.ID), Name: user.Name, Email: user.Email}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
